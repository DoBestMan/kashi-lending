{
    "language": "Solidity",
    "sources": {
        "contracts/flat/BoringHelperFlat.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// Copyright (c) 2021 BoringCrypto\n// Twitter: @Boring_Crypto\n\n// Version 22-Mar-2021\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function owner() external view returns (address);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IMasterChef {\n    function BONUS_MULTIPLIER() external view returns (uint256);\n    function bonusEndBlock() external view returns (uint256);\n    function devaddr() external view returns (address);\n    function migrator() external view returns (address);\n    function owner() external view returns (address);\n    function startBlock() external view returns (uint256);\n    function sushi() external view returns (address);\n    function sushiPerBlock() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n    function poolLength() external view returns (uint256);\n\n    function poolInfo(uint256 nr)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface IPair is IERC20 {\n    function token0() external view returns (IERC20);\n    function token1() external view returns (IERC20);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112,\n            uint112,\n            uint32\n        );\n}\n\ninterface IFactory {\n    function allPairsLength() external view returns (uint256);\n    function allPairs(uint256 i) external view returns (IPair);\n    function getPair(IERC20 token0, IERC20 token1) external view returns (IPair);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n}\n\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n}\n\ncontract Ownable {\n    address public immutable owner;\n\n    constructor() internal {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\nlibrary BoringERC20 {\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while(i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    } \n    \n    function symbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    function name(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    function decimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function DOMAIN_SEPARATOR(IERC20 token) internal view returns (bytes32) {\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 10000 }(abi.encodeWithSelector(0x3644e515));\n        return success && data.length == 32 ? abi.decode(data, (bytes32)) : bytes32(0);\n    }\n\n    function nonces(IERC20 token, address owner) internal view returns (uint256) {\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 5000 }(abi.encodeWithSelector(0x7ecebe00, owner));\n        return success && data.length == 32 \n            ? abi.decode(data, (uint256)) \n            : uint256(-1); // Use max uint256 to signal failure to retrieve nonce (probably not supported)\n    }\n}\n\nlibrary BoringPair {\n    function factory(IPair pair) internal view returns (IFactory) {\n        (bool success, bytes memory data) = address(pair).staticcall(abi.encodeWithSelector(0xc45a0155));\n        return success && data.length == 32 ? abi.decode(data, (IFactory)) : IFactory(0);\n    }\n}\n\ninterface IStrategy {\n    function skim(uint256 amount) external;\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n\ninterface IBentoBox {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\n    event LogRegisterProtocol(address indexed protocol);\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\n    event LogStrategyDivest(address indexed token, uint256 amount);\n    event LogStrategyInvest(address indexed token, uint256 amount);\n    event LogStrategyLoss(address indexed token, uint256 amount);\n    event LogStrategyProfit(address indexed token, uint256 amount);\n    event LogStrategyQueued(address indexed token, address indexed strategy);\n    event LogStrategySet(address indexed token, address indexed strategy);\n    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function balanceOf(IERC20, address) external view returns (uint256);\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n    function claimOwnership() external;\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable;\n    function deposit(IERC20 token_, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\n    function masterContractApproved(address, address) external view returns (bool);\n    function masterContractOf(address) external view returns (address);\n    function nonces(address) external view returns (uint256);\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function registerProtocol() external;\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n    function strategy(IERC20) external view returns (IStrategy);\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\n    function totals(IERC20) external view returns (uint128 elastic, uint128 base);\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n    function whitelistMasterContract(address masterContract, bool approved) external;\n    function whitelistedMasterContracts(address) external view returns (bool);\n    function withdraw(IERC20 token_, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);\n}\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\nstruct AccrueInfo {\n    uint64 interestPerSecond;\n    uint64 lastAccrued;\n    uint128 feesEarnedFraction;\n}\n\ninterface IOracle {\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n    function symbol(bytes calldata data) external view returns (string memory);\n    function name(bytes calldata data) external view returns (string memory);\n}\n\ninterface IKashiPair {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function accrue() external;\n    function accrueInfo() external view returns (AccrueInfo memory info);\n    function addAsset(address to, bool skim, uint256 share) external returns (uint256 fraction);\n    function addCollateral(address to, bool skim, uint256 share) external;\n    function allowance(address, address) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function asset() external view returns (IERC20);\n    function balanceOf(address) external view returns (uint256);\n    function bentoBox() external view returns (IBentoBox);\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\n    function claimOwnership() external;\n    function collateral() external view returns (IERC20);\n    function cook(uint8[] calldata actions, uint256[] calldata values, bytes[] calldata datas) external payable returns (uint256 value1, uint256 value2);\n    function decimals() external view returns (uint8);\n    function exchangeRate() external view returns (uint256);\n    function feeTo() external view returns (address);\n    function getInitData(IERC20 collateral_, IERC20 asset_, address oracle_, bytes calldata oracleData_) external pure returns (bytes memory data);\n    function init(bytes calldata data) external payable;\n    function isSolvent(address user, bool open) external view returns (bool);\n    function liquidate(address[] calldata users, uint256[] calldata borrowParts, address to, address swapper, bool open) external;\n    function masterContract() external view returns (address);\n    function name() external view returns (string memory);\n    function nonces(address) external view returns (uint256);\n    function oracle() external view returns (IOracle);\n    function oracleData() external view returns (bytes memory);\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\n    function removeCollateral(address to, uint256 share) external;\n    function repay(address to, bool skim, uint256 part) external returns (uint256 amount);\n    function setFeeTo(address newFeeTo) external;\n    function setSwapper(address swapper, bool enable) external;\n    function swappers(address) external view returns (bool);\n    function symbol() external view returns (string memory);\n    function totalAsset() external view returns (Rebase memory total);\n    function totalBorrow() external view returns (Rebase memory total);\n    function totalCollateralShare() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\n    function userBorrowPart(address) external view returns (uint256);\n    function userCollateralShare(address) external view returns (uint256);\n    function withdrawFees() external;\n}\n\ncontract BoringHelperV1 is Ownable {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n    using BoringERC20 for IPair;\n    using BoringPair for IPair;\n\n    IMasterChef public chef; // IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n    address public maker; // ISushiMaker(0xE11fc0B43ab98Eb91e9836129d1ee7c3Bc95df50);\n    IERC20 public sushi; // ISushiToken(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n    IERC20 public WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IERC20 public WBTC; // 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    IFactory public sushiFactory; // IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n    IFactory public uniV2Factory; // IFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    IERC20 public bar; // 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272;\n    IBentoBox public bentoBox; // 0xB5891167796722331b7ea7824F036b3Bdcb4531C\n\n    constructor(\n        IMasterChef chef_,\n        address maker_,\n        IERC20 sushi_,\n        IERC20 WETH_,\n        IERC20 WBTC_,\n        IFactory sushiFactory_,\n        IFactory uniV2Factory_,\n        IERC20 bar_,\n        IBentoBox bentoBox_\n    ) public {\n        chef = chef_;\n        maker = maker_;\n        sushi = sushi_;\n        WETH = WETH_;\n        WBTC = WBTC_;\n        sushiFactory = sushiFactory_;\n        uniV2Factory = uniV2Factory_;\n        bar = bar_;\n        bentoBox = bentoBox_;\n    }\n\n    function setContracts(\n        IMasterChef chef_,\n        address maker_,\n        IERC20 sushi_,\n        IERC20 WETH_,\n        IERC20 WBTC_,\n        IFactory sushiFactory_,\n        IFactory uniV2Factory_,\n        IERC20 bar_,\n        IBentoBox bentoBox_\n    ) public onlyOwner {\n        chef = chef_;\n        maker = maker_;\n        sushi = sushi_;\n        WETH = WETH_;\n        WBTC = WBTC_;\n        sushiFactory = sushiFactory_;\n        uniV2Factory = uniV2Factory_;\n        bar = bar_;\n        bentoBox = bentoBox_;\n    }\n\n    function getETHRate(IERC20 token) public view returns (uint256) {\n        if (token == WETH) {\n            return 1e18;\n        }\n        IPair pairUniV2;\n        IPair pairSushi;\n        if (uniV2Factory != IFactory(0)) {\n            pairUniV2 = IPair(uniV2Factory.getPair(token, WETH));\n        }\n        if (sushiFactory != IFactory(0)) {\n            pairSushi = IPair(sushiFactory.getPair(token, WETH));\n        }\n        if (address(pairUniV2) == address(0) && address(pairSushi) == address(0)) {\n            return 0;\n        }\n\n        uint112 reserve0;\n        uint112 reserve1;\n        IERC20 token0;\n        if (address(pairUniV2) != address(0)) {\n            (uint112 reserve0UniV2, uint112 reserve1UniV2, ) = pairUniV2.getReserves();\n            reserve0 += reserve0UniV2;\n            reserve1 += reserve1UniV2;\n            token0 = pairUniV2.token0();\n        }\n\n        if (address(pairSushi) != address(0)) {\n            (uint112 reserve0Sushi, uint112 reserve1Sushi, ) = pairSushi.getReserves();\n            reserve0 += reserve0Sushi;\n            reserve1 += reserve1Sushi;\n            if (token0 == IERC20(0)) {\n                token0 = pairSushi.token0();\n            }\n        }\n\n        if (token0 == WETH) {\n            return uint256(reserve1) * 1e18 / reserve0;\n        } else {\n            return uint256(reserve0) * 1e18 / reserve1;\n        }\n    }\n\n    struct Factory {\n        IFactory factory;\n        uint256 allPairsLength;\n    }\n\n    struct UIInfo {\n        uint256 ethBalance;\n        uint256 sushiBalance;\n        uint256 sushiBarBalance;\n        uint256 xsushiBalance;\n        uint256 xsushiSupply;\n        uint256 sushiBarAllowance;\n        Factory[] factories;\n        uint256 ethRate;\n        uint256 sushiRate;\n        uint256 btcRate;\n        uint256 pendingSushi;\n        uint256 blockTimeStamp;\n        bool[] masterContractApproved;\n    }\n\n    function getUIInfo(\n        address who,\n        IFactory[] calldata factoryAddresses,\n        IERC20 currency,\n        address[] calldata masterContracts\n    ) public view returns (UIInfo memory) {\n        UIInfo memory info;\n        info.ethBalance = who.balance;\n\n        info.factories = new Factory[](factoryAddresses.length);\n        for (uint256 i = 0; i < factoryAddresses.length; i++) {\n            IFactory factory = factoryAddresses[i];\n            info.factories[i].factory = factory;\n            info.factories[i].allPairsLength = factory.allPairsLength();\n        }\n\n        info.masterContractApproved = new bool[](masterContracts.length);\n        for (uint256 i = 0; i < masterContracts.length; i++) {\n            info.masterContractApproved[i] = bentoBox.masterContractApproved(masterContracts[i], who);\n        }\n\n        if (currency != IERC20(0)) {\n            info.ethRate = getETHRate(currency);\n        }\n\n        if (WBTC != IERC20(0)) {\n            info.btcRate = getETHRate(WBTC);\n        }\n\n        if (sushi != IERC20(0)) {\n            info.sushiRate = getETHRate(sushi);\n            info.sushiBalance = sushi.balanceOf(who);\n            info.sushiBarBalance = sushi.balanceOf(address(bar));\n            info.sushiBarAllowance = sushi.allowance(who, address(bar));\n        }\n\n        if (bar != IERC20(0)) {\n            info.xsushiBalance = bar.balanceOf(who);\n            info.xsushiSupply = bar.totalSupply();\n        }\n\n        if (chef != IMasterChef(0)) {\n            uint256 poolLength = chef.poolLength();\n            uint256 pendingSushi;\n            for (uint256 i = 0; i < poolLength; i++) {\n                pendingSushi += chef.pendingSushi(i, who);\n            }\n            info.pendingSushi = pendingSushi;\n        }\n        info.blockTimeStamp = block.timestamp;\n\n        return info;\n    }\n\n    struct Balance {\n        IERC20 token;\n        uint256 balance;\n        uint256 bentoBalance;\n    }\n\n    struct BalanceFull {\n        IERC20 token;\n        uint256 totalSupply;\n        uint256 balance;\n        uint256 bentoBalance;\n        uint256 bentoAllowance;\n        uint256 nonce;\n        uint128 bentoAmount;\n        uint128 bentoShare;\n        uint256 rate;\n    }\n\n    struct TokenInfo {\n        IERC20 token;\n        uint256 decimals;\n        string name;\n        string symbol;\n        bytes32 DOMAIN_SEPARATOR;\n    }\n\n    function getTokenInfo(address[] calldata addresses) public view returns (TokenInfo[] memory) {\n        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            infos[i].token = token;\n\n            infos[i].name = token.name();\n            infos[i].symbol = token.symbol();\n            infos[i].decimals = token.decimals();\n            infos[i].DOMAIN_SEPARATOR = token.DOMAIN_SEPARATOR();\n        }\n\n        return infos;\n    }\n\n    function findBalances(address who, address[] calldata addresses) public view returns (Balance[] memory) {\n        Balance[] memory balances = new Balance[](addresses.length);\n\n        uint256 len = addresses.length;\n        for (uint256 i = 0; i < len; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            balances[i].token = token;\n            balances[i].balance = token.balanceOf(who);\n            balances[i].bentoBalance = bentoBox.balanceOf(token, who);\n        }\n\n        return balances;\n    }\n\n    function getBalances(address who, IERC20[] calldata addresses) public view returns (BalanceFull[] memory) {\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = addresses[i];\n            balances[i].totalSupply = token.totalSupply();\n            balances[i].token = token;\n            balances[i].balance = token.balanceOf(who);\n            balances[i].bentoAllowance = token.allowance(who, address(bentoBox));\n            balances[i].nonce = token.nonces(who);\n            balances[i].bentoBalance = bentoBox.balanceOf(token, who);\n            (balances[i].bentoAmount, balances[i].bentoShare) = bentoBox.totals(token);\n            balances[i].rate = getETHRate(token);\n        }\n\n        return balances;\n    }\n\n    struct PairBase {\n        IPair token;\n        IERC20 token0;\n        IERC20 token1;\n        uint256 totalSupply;\n    }\n\n    function getPairs(\n        IFactory factory,\n        uint256 fromID,\n        uint256 toID\n    ) public view returns (PairBase[] memory) {\n        PairBase[] memory pairs = new PairBase[](toID - fromID);\n\n        for (uint256 id = fromID; id < toID; id++) {\n            IPair token = factory.allPairs(id);\n            uint256 i = id - fromID;\n            pairs[i].token = token;\n            pairs[i].token0 = token.token0();\n            pairs[i].token1 = token.token1();\n            pairs[i].totalSupply = token.totalSupply();\n        }\n        return pairs;\n    }\n\n    struct PairPoll {\n        IPair token;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n        uint256 balance;\n    }\n\n    function pollPairs(address who, IPair[] calldata addresses) public view returns (PairPoll[] memory) {\n        PairPoll[] memory pairs = new PairPoll[](addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IPair token = addresses[i];\n            pairs[i].token = token;\n            (uint256 reserve0, uint256 reserve1, ) = token.getReserves();\n            pairs[i].reserve0 = reserve0;\n            pairs[i].reserve1 = reserve1;\n            pairs[i].balance = token.balanceOf(who);\n            pairs[i].totalSupply = token.totalSupply();\n        }\n        return pairs;\n    }\n\n    struct PoolsInfo {\n        uint256 totalAllocPoint;\n        uint256 poolLength;\n    }\n\n    struct PoolInfo {\n        uint256 pid;\n        IPair lpToken;\n        uint256 allocPoint;\n        bool isPair;\n        IFactory factory;\n        IERC20 token0;\n        IERC20 token1;\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    function getPools(uint256[] calldata pids) public view returns (PoolsInfo memory, PoolInfo[] memory) {\n        PoolsInfo memory info;\n        info.totalAllocPoint = chef.totalAllocPoint();\n        uint256 poolLength = chef.poolLength();\n        info.poolLength = poolLength;\n\n        PoolInfo[] memory pools = new PoolInfo[](pids.length);\n\n        for (uint256 i = 0; i < pids.length; i++) {\n            pools[i].pid = pids[i];\n            (address lpToken, uint256 allocPoint, , ) = chef.poolInfo(pids[i]);\n            IPair uniV2 = IPair(lpToken);\n            pools[i].lpToken = uniV2;\n            pools[i].allocPoint = allocPoint;\n\n            pools[i].name = uniV2.name();\n            pools[i].symbol = uniV2.symbol();\n            pools[i].decimals = uniV2.decimals();\n\n            pools[i].factory = uniV2.factory();\n            if (pools[i].factory != IFactory(0)) {\n                pools[i].isPair = true;\n                pools[i].token0 = uniV2.token0();\n                pools[i].token1 = uniV2.token1();\n            }\n        }\n        return (info, pools);\n    }\n\n    struct PoolFound {\n        uint256 pid;\n        uint256 balance;\n    }\n\n    function findPools(address who, uint256[] calldata pids) public view returns (PoolFound[] memory) {\n        PoolFound[] memory pools = new PoolFound[](pids.length);\n\n        for (uint256 i = 0; i < pids.length; i++) {\n            pools[i].pid = pids[i];\n            (pools[i].balance, ) = chef.userInfo(pids[i], who);\n        }\n\n        return pools;\n    }\n\n    struct UserPoolInfo {\n        uint256 pid;\n        uint256 balance; // Balance of pool tokens\n        uint256 totalSupply; // Token staked lp tokens\n        uint256 lpBalance; // Balance of lp tokens not staked\n        uint256 lpTotalSupply; // TotalSupply of lp tokens\n        uint256 lpAllowance; // LP tokens approved for masterchef\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 rewardDebt;\n        uint256 pending; // Pending SUSHI\n    }\n\n    function pollPools(address who, uint256[] calldata pids) public view returns (UserPoolInfo[] memory) {\n        UserPoolInfo[] memory pools = new UserPoolInfo[](pids.length);\n\n        for (uint256 i = 0; i < pids.length; i++) {\n            (uint256 amount, ) = chef.userInfo(pids[i], who);\n            pools[i].balance = amount;\n            pools[i].pending = chef.pendingSushi(pids[i], who);\n\n            (address lpToken, , , ) = chef.poolInfo(pids[i]);\n            pools[i].pid = pids[i];\n            IPair uniV2 = IPair(lpToken);\n            IFactory factory = uniV2.factory();\n            if (factory != IFactory(0)) {\n                pools[i].totalSupply = uniV2.balanceOf(address(chef));\n                pools[i].lpAllowance = uniV2.allowance(who, address(chef));\n                pools[i].lpBalance = uniV2.balanceOf(who);\n                pools[i].lpTotalSupply = uniV2.totalSupply();\n\n                (uint112 reserve0, uint112 reserve1, ) = uniV2.getReserves();\n                pools[i].reserve0 = reserve0;\n                pools[i].reserve1 = reserve1;\n            }\n        }\n        return pools;\n    }\n\n    struct KashiPairPoll {\n        IERC20 collateral;\n        IERC20 asset;\n        IOracle oracle;\n        bytes oracleData;\n        uint256 totalCollateralShare;\n        uint256 userCollateralShare;\n        Rebase totalAsset;\n        uint256 userAssetFraction;\n        Rebase totalBorrow;\n        uint256 userBorrowPart;\n        uint256 currentExchangeRate;\n        uint256 spotExchangeRate;\n        uint256 oracleExchangeRate;\n        AccrueInfo accrueInfo;\n    }\n\n    function pollKashiPairs(address who, IKashiPair[] calldata pairsIn) public view returns (KashiPairPoll[] memory) {\n        uint256 len = pairsIn.length;\n        KashiPairPoll[] memory pairs = new KashiPairPoll[](len);\n\n        for (uint256 i = 0; i < len; i++) {\n            IKashiPair pair = pairsIn[i];\n            pairs[i].collateral = pair.collateral();\n            pairs[i].asset = pair.asset();\n            pairs[i].oracle = pair.oracle();\n            pairs[i].oracleData = pair.oracleData();\n            pairs[i].totalCollateralShare = pair.totalCollateralShare();\n            pairs[i].userCollateralShare = pair.userCollateralShare(who); \n            pairs[i].totalAsset = pair.totalAsset();\n            pairs[i].userAssetFraction = pair.balanceOf(who);\n            pairs[i].totalBorrow = pair.totalBorrow();\n            pairs[i].userBorrowPart = pair.userBorrowPart(who);\n\n            pairs[i].currentExchangeRate = pair.exchangeRate();\n            (, pairs[i].oracleExchangeRate) = pair.oracle().peek(pair.oracleData());\n            pairs[i].spotExchangeRate = pair.oracle().peekSpot(pair.oracleData());\n            pairs[i].accrueInfo = pair.accrueInfo();\n        }\n\n        return pairs;\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 999999
        },
        "outputSelection": {
            "*": {
                "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"],
                "": ["ast"]
            }
        }
    }
}
