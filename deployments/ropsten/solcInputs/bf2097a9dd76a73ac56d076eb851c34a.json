{
    "language": "Solidity",
    "sources": {
        "contracts/flat/SimpleSLPTWAP0OracleFlat.sol": {
            "content": "// SPDX-License-Identifier: MIXED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// solhint-disable not-rely-on-time\n\n// File contracts/interfaces/IOracle.sol\n// License-Identifier: MIT\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.1\n// License-Identifier: MIT\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol@v1.4.2\n// License-Identifier: GPL-3.0\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setMigrator(address) external;\n}\n\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol@v1.4.2\n// License-Identifier: GPL-3.0\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// File contracts/libraries/FullMath.sol\n// License-Identifier: CC-BY-4.0\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, \"FullMath::mulDiv: overflow\");\n        return fullDiv(l, h, d);\n    }\n}\n\n// File contracts/libraries/FixedPoint.sol\n// License-Identifier: GPL-3.0-or-later\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint256, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // lossy if either numerator or denominator is greater than 112 bits\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint::fraction: div by 0\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n}\n\n// File contracts/oracles/SimpleSLPTWAP0Oracle.sol\n// License-Identifier: AGPL-3.0-only\n// Using the same Copyleft License as in the original Repository\n\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\n\ncontract SimpleSLPTWAP0OracleV1 is IOracle {\n    using FixedPoint for *;\n    using BoringMath for uint256;\n    uint256 public constant PERIOD = 5 minutes;\n\n    struct PairInfo {\n        uint256 priceCumulativeLast;\n        uint32 blockTimestampLast;\n        uint144 priceAverage;\n    }\n\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\n\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\n        uint256 priceCumulative = pair.price0CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        return priceCumulative;\n    }\n\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) {\n        return abi.encode(pair);\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) external override returns (bool, uint256) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairs[pair].blockTimestampLast == 0) {\n            pairs[pair].blockTimestampLast = blockTimestamp;\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairs[pair].priceAverage);\n        }\n\n        uint256 priceCumulative = _get(pair, blockTimestamp);\n        pairs[pair].priceAverage = FixedPoint\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144();\n        pairs[pair].blockTimestampLast = blockTimestamp;\n        pairs[pair].priceCumulativeLast = priceCumulative;\n\n        return (true, pairs[pair].priceAverage);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairs[pair].blockTimestampLast == 0) {\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairs[pair].priceAverage);\n        }\n\n        uint256 priceCumulative = _get(pair, blockTimestamp);\n        uint144 priceAverage =\n            FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed)).mul(1e18).decode144();\n\n        return (true, priceAverage);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        rate = reserve1.mul(1e18) / reserve0;\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"SushiSwap TWAP\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"TWAP\";\n    }\n}"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 999999
        },
        "outputSelection": {
            "*": {
                "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers"],
                "": ["ast"]
            }
        }
    }
}
